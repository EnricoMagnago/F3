@TIME_DOMAIN continuous
MODULE main
DEFINE
  N := 19;
  A_ := 25;
  B := 50;
VAR
  id : 0..N;
  c : Counter(N, id);
  a0 : Arbiter(1, id);
  a1 : Arbiter(2, id);
  a2 : Arbiter(3, id);
  a3 : Arbiter(4, id);
  a4 : Arbiter(5, id);
  a5 : Arbiter(6, id);
  a6 : Arbiter(7, id);
  a7 : Arbiter(8, id);
  a8 : Arbiter(9, id);
  a9 : Arbiter(10, id);
  a10 : Arbiter(11, id);
  a11 : Arbiter(12, id);
  a12 : Arbiter(13, id);
  a13 : Arbiter(14, id);
  a14 : Arbiter(15, id);
  a15 : Arbiter(16, id);
  a16 : Arbiter(17, id);
  a17 : Arbiter(18, id);
  a18 : Arbiter(19, id);

  pc0 : ProdCell(A_, B);
  pc1 : ProdCell(A_, B);
  pc2 : ProdCell(A_, B);
  pc3 : ProdCell(A_, B);
  pc4 : ProdCell(A_, B);
  pc5 : ProdCell(A_, B);
  pc6 : ProdCell(A_, B);
  pc7 : ProdCell(A_, B);
  pc8 : ProdCell(A_, B);
  pc9 : ProdCell(A_, B);
  pc10 : ProdCell(A_, B);
  pc11 : ProdCell(A_, B);
  pc12 : ProdCell(A_, B);
  pc13 : ProdCell(A_, B);
  pc14 : ProdCell(A_, B);
  pc15 : ProdCell(A_, B);
  pc16 : ProdCell(A_, B);
  pc17 : ProdCell(A_, B);
  pc18 : ProdCell(A_, B);


TRANS (c.evt_stutter & a0.evt_stutter & a1.evt_stutter & a2.evt_stutter & a3.evt_stutter & a4.evt_stutter & a5.evt_stutter & a6.evt_stutter & a7.evt_stutter & a8.evt_stutter & a9.evt_stutter & a10.evt_stutter & a11.evt_stutter & a12.evt_stutter & a13.evt_stutter & a14.evt_stutter & a15.evt_stutter & a16.evt_stutter & a17.evt_stutter & a18.evt_stutter) -> next(id) = id;
-- sync arbiter and prodcell
TRANS (a0.evt_enter <-> pc0.evt_enter) & (a0.evt_exit <-> pc0.evt_exit);
TRANS (a1.evt_enter <-> pc1.evt_enter) & (a1.evt_exit <-> pc1.evt_exit);
TRANS (a2.evt_enter <-> pc2.evt_enter) & (a2.evt_exit <-> pc2.evt_exit);
TRANS (a3.evt_enter <-> pc3.evt_enter) & (a3.evt_exit <-> pc3.evt_exit);
TRANS (a4.evt_enter <-> pc4.evt_enter) & (a4.evt_exit <-> pc4.evt_exit);
TRANS (a5.evt_enter <-> pc5.evt_enter) & (a5.evt_exit <-> pc5.evt_exit);
TRANS (a6.evt_enter <-> pc6.evt_enter) & (a6.evt_exit <-> pc6.evt_exit);
TRANS (a7.evt_enter <-> pc7.evt_enter) & (a7.evt_exit <-> pc7.evt_exit);
TRANS (a8.evt_enter <-> pc8.evt_enter) & (a8.evt_exit <-> pc8.evt_exit);
TRANS (a9.evt_enter <-> pc9.evt_enter) & (a9.evt_exit <-> pc9.evt_exit);
TRANS (a10.evt_enter <-> pc10.evt_enter) & (a10.evt_exit <-> pc10.evt_exit);
TRANS (a11.evt_enter <-> pc11.evt_enter) & (a11.evt_exit <-> pc11.evt_exit);
TRANS (a12.evt_enter <-> pc12.evt_enter) & (a12.evt_exit <-> pc12.evt_exit);
TRANS (a13.evt_enter <-> pc13.evt_enter) & (a13.evt_exit <-> pc13.evt_exit);
TRANS (a14.evt_enter <-> pc14.evt_enter) & (a14.evt_exit <-> pc14.evt_exit);
TRANS (a15.evt_enter <-> pc15.evt_enter) & (a15.evt_exit <-> pc15.evt_exit);
TRANS (a16.evt_enter <-> pc16.evt_enter) & (a16.evt_exit <-> pc16.evt_exit);
TRANS (a17.evt_enter <-> pc17.evt_enter) & (a17.evt_exit <-> pc17.evt_exit);
TRANS (a18.evt_enter <-> pc18.evt_enter) & (a18.evt_exit <-> pc18.evt_exit);


INVARSPEC pc0.l != error;
LTLSPEC (G (pc0.l != error | pc1.l != error)) -> G F id = 0;

MODULE Counter(N, id)
IVAR event : {stutter, move};
DEFINE
  evt_stutter := event = stutter;
  evt_move := event = move;
VAR
  l : {initial, initCount};

INIT l = initial;

TRANS evt_stutter -> next(l) = l;

-- initial -> initCount
TRANS (!evt_stutter & l = initial) -> (id = 0 & next(id) = 1 & next(l) = initCount);

-- initCount -> initCount
TRANS (!evt_stutter & l = initCount) -> (next(l) = initCount);
TRANS (l = initCount & next(l) = initCount & id >= N) -> (next(id) = 1);
TRANS (l = initCount & next(l) = initCount & id < N) -> (next(id) = id + 1);


MODULE Arbiter(i, id)
IVAR event : {stutter, enter, exit};
DEFINE
  evt_stutter := event = stutter;
  evt_enter := event = enter;
  evt_exit := event = exit;
VAR
  l : {s0, s1};

INIT l = s1;

TRANS (evt_stutter) -> next(l) = l;
-- s1 -> s0
TRANS (!evt_stutter & l = s1) -> (next(l) = s0 & evt_enter & id = i & next(id) = 0);
-- s0 -> s1
TRANS (!evt_stutter & l = s0) -> (next(l) = s1 & evt_exit & next(id) = i);


MODULE ProdCell(A_, B)
IVAR event : {stutter, enter, exit, move};
DEFINE
  evt_stutter := event = stutter;
  evt_enter := event = enter;
  evt_exit := event = exit;
  evt_move := event = move;
VAR
  l : {not_ready, testing, requesting, critical, testing2, safe, error};
  x : clock;

INIT l = not_ready & x = 0;

INVAR (l = testing | l = testing2) -> x <= A_;

TRANS evt_stutter -> (next(l) = l & next(x) = x);

-- not_ready -> testing
TRANS (!evt_stutter & l = not_ready) -> (evt_move & x <= B & next(x) = 0 & next(l) = testing);

-- testing -> [not_ready | requesting]
TRANS (!evt_stutter & l = testing) -> ((next(l) = not_ready | next(l) = requesting) & evt_move);
TRANS (l = testing & next(l) = not_ready) -> (x >= A_ & next(x) = 0);
TRANS (l = testing & next(l) = requesting) -> (x <= A_ - 1 & next(x) = x);

-- requesting -> critical
TRANS (!evt_stutter & l = requesting) -> (next(l) = critical & evt_enter & next(x) = 0);

-- critical -> [error | testing2]
TRANS (!evt_stutter & l = critical) -> (next(l) = error | next(l) = testing2);
TRANS (l = critical & next(l) = error) -> (evt_move & x >= B & next(x) = x);
TRANS (l = critical & next(l) = testing2) -> (evt_exit & x <= A_ - 1 & next(x) = 0);

-- testing2 -> [error | safe]
TRANS (!evt_stutter & l = testing2) -> ((next(l) = error | next(l) = safe) & evt_move & next(x) = x);
TRANS (l = testing2 & next(l) = error) -> (x >= A_);
TRANS (l = testing2 & next(l) = safe) -> (x <= A_ - 1);

-- error -> error
TRANS (!evt_stutter & l = error) -> next(l) = error;

-- safe -> not_ready
TRANS (!evt_stutter & l = safe) -> next(l) = not_ready;
