MODULE main
DEFINE
  A_ := 25;
  Am1 := 24;
  B := 50;
VAR
  id : 0..6;
  c : Counter(6, id);
  a0 : Arbiter(1, id);
  a1 : Arbiter(2, id);
  a2 : Arbiter(3, id);
  a3 : Arbiter(4, id);
  a4 : Arbiter(5, id);
  a5 : Arbiter(6, id);

  pc0 : ProdCell(A_, Am1, B);
  pc1 : ProdCell(A_, Am1, B);
  pc2 : ProdCell(A_, Am1, B);
  pc3 : ProdCell(A_, Am1, B);
  pc4 : ProdCell(A_, Am1, B);
  pc5 : ProdCell(A_, Am1, B);


TRANS ((c.evt = stutter) & (a0.evt = stutter) & (a1.evt = stutter) & (a2.evt = stutter) & (a3.evt = stutter) & (a4.evt = stutter) & (a5.evt = stutter)) -> next(id) = id;
-- sync arbiter and prodcell
TRANS ((a0.evt = enter) <-> (pc0.evt = enter)) & ((a0.evt = exit) <-> (pc0.evt = exit));
TRANS ((a1.evt = enter) <-> (pc1.evt = enter)) & ((a1.evt = exit) <-> (pc1.evt = exit));
TRANS ((a2.evt = enter) <-> (pc2.evt = enter)) & ((a2.evt = exit) <-> (pc2.evt = exit));
TRANS ((a3.evt = enter) <-> (pc3.evt = enter)) & ((a3.evt = exit) <-> (pc3.evt = exit));
TRANS ((a4.evt = enter) <-> (pc4.evt = enter)) & ((a4.evt = exit) <-> (pc4.evt = exit));
TRANS ((a5.evt = enter) <-> (pc5.evt = enter)) & ((a5.evt = exit) <-> (pc5.evt = exit));


MITLSPEC (FALSE SR (pc0.l != error | pc1.l != error)) -> (FALSE SR (TRUE SU (id = 0)));

MODULE Counter(N, id)
VAR
  evt : {stutter, move};
  l : {initial, initCount};

INIT l = initial;

TRANS (evt = stutter) -> next(l) = l;

-- initial -> initCount
TRANS (evt != stutter & l = initial) -> (id = 0 & next(id) = 1 & next(l) = initCount);

-- initCount -> initCount
TRANS (evt != stutter & l = initCount) -> (next(l) = initCount);
TRANS (l = initCount & next(l) = initCount & id >= N) -> (next(id) = 1);
TRANS (l = initCount & next(l) = initCount & id < N) -> (next(id) = id + 1);


MODULE Arbiter(i, id)
VAR
  evt : {stutter, enter, exit};
  l : {s0, s1};

INIT l = s1;

TRANS (evt = stutter) -> next(l) = l;
-- s1 -> s0
TRANS (evt != stutter & l = s1) -> (next(l) = s0 & evt = enter & id = i & next(id) = 0);
-- s0 -> s1
TRANS (evt != stutter & l = s0) -> (next(l) = s1 & evt = exit & next(id) = i);


MODULE ProdCell(A_, Am1, B)
VAR
  evt : {stutter, enter, exit, move};
  l : {not_ready, testing, requesting, critical, testing2, safe, error};
  x : clock((l = not_ready & next(l) = testing) |
            (l = testing & next(l) = not_ready) |
            (l = requesting & next(l) = critical) |
            (l = critical & next(l) = testing2));

INIT l = not_ready;

INVAR (l = testing | l = testing2) -> x <= A_;

TRANS evt = stutter -> (next(l) = l);

-- not_ready -> testing
TRANS (evt != stutter & l = not_ready) -> (evt = move & x <= B & next(l) = testing);

-- testing -> [not_ready | requesting]
TRANS(evt != stutter & l = testing) -> ((next(l) = not_ready | next(l) = requesting) & evt = move);
TRANS (l = testing & next(l) = not_ready) -> (x >= A_);
TRANS (l = testing & next(l) = requesting) -> (x <= Am1);

-- requesting -> critical
TRANS (evt != stutter & l = requesting) -> (next(l) = critical & evt = enter);

-- critical -> [error | testing2]
TRANS (evt != stutter & l = critical) -> (next(l) = error | next(l) = testing2);
TRANS (l = critical & next(l) = error) -> (evt = move & x >= B);
TRANS (l = critical & next(l) = testing2) -> (evt = exit & x <= Am1);

-- testing2 -> [error | safe]
TRANS (evt != stutter & l = testing2) -> ((next(l) = error | next(l) = safe) & evt = move);
TRANS (l = testing2 & next(l) = error) -> (x >= A_);
TRANS (l = testing2 & next(l) = safe) -> (x <= Am1);

-- error -> error
TRANS (evt != stutter & l = error) -> next(l) = error

-- safe -> not_ready
TRANS (evt != stutter & l = safe) -> next(l) = not_ready;
