MODULE main
DEFINE
  A_ := 25;
  Am1 := 24;
  B := 50;
VAR
  id : 0..18;
  c : Counter(18, id);
  a0 : Arbiter(1, id);
  a1 : Arbiter(2, id);
  a2 : Arbiter(3, id);
  a3 : Arbiter(4, id);
  a4 : Arbiter(5, id);
  a5 : Arbiter(6, id);
  a6 : Arbiter(7, id);
  a7 : Arbiter(8, id);
  a8 : Arbiter(9, id);
  a9 : Arbiter(10, id);
  a10 : Arbiter(11, id);
  a11 : Arbiter(12, id);
  a12 : Arbiter(13, id);
  a13 : Arbiter(14, id);
  a14 : Arbiter(15, id);
  a15 : Arbiter(16, id);
  a16 : Arbiter(17, id);
  a17 : Arbiter(18, id);

  pc0 : ProdCell(A_, Am1, B);
  pc1 : ProdCell(A_, Am1, B);
  pc2 : ProdCell(A_, Am1, B);
  pc3 : ProdCell(A_, Am1, B);
  pc4 : ProdCell(A_, Am1, B);
  pc5 : ProdCell(A_, Am1, B);
  pc6 : ProdCell(A_, Am1, B);
  pc7 : ProdCell(A_, Am1, B);
  pc8 : ProdCell(A_, Am1, B);
  pc9 : ProdCell(A_, Am1, B);
  pc10 : ProdCell(A_, Am1, B);
  pc11 : ProdCell(A_, Am1, B);
  pc12 : ProdCell(A_, Am1, B);
  pc13 : ProdCell(A_, Am1, B);
  pc14 : ProdCell(A_, Am1, B);
  pc15 : ProdCell(A_, Am1, B);
  pc16 : ProdCell(A_, Am1, B);
  pc17 : ProdCell(A_, Am1, B);


TRANS ((c.evt = stutter) & (a0.evt = stutter) & (a1.evt = stutter) & (a2.evt = stutter) & (a3.evt = stutter) & (a4.evt = stutter) & (a5.evt = stutter) & (a6.evt = stutter) & (a7.evt = stutter) & (a8.evt = stutter) & (a9.evt = stutter) & (a10.evt = stutter) & (a11.evt = stutter) & (a12.evt = stutter) & (a13.evt = stutter) & (a14.evt = stutter) & (a15.evt = stutter) & (a16.evt = stutter) & (a17.evt = stutter)) -> next(id) = id;
-- sync arbiter and prodcell
TRANS ((a0.evt = enter) <-> (pc0.evt = enter)) & ((a0.evt = exit) <-> (pc0.evt = exit));
TRANS ((a1.evt = enter) <-> (pc1.evt = enter)) & ((a1.evt = exit) <-> (pc1.evt = exit));
TRANS ((a2.evt = enter) <-> (pc2.evt = enter)) & ((a2.evt = exit) <-> (pc2.evt = exit));
TRANS ((a3.evt = enter) <-> (pc3.evt = enter)) & ((a3.evt = exit) <-> (pc3.evt = exit));
TRANS ((a4.evt = enter) <-> (pc4.evt = enter)) & ((a4.evt = exit) <-> (pc4.evt = exit));
TRANS ((a5.evt = enter) <-> (pc5.evt = enter)) & ((a5.evt = exit) <-> (pc5.evt = exit));
TRANS ((a6.evt = enter) <-> (pc6.evt = enter)) & ((a6.evt = exit) <-> (pc6.evt = exit));
TRANS ((a7.evt = enter) <-> (pc7.evt = enter)) & ((a7.evt = exit) <-> (pc7.evt = exit));
TRANS ((a8.evt = enter) <-> (pc8.evt = enter)) & ((a8.evt = exit) <-> (pc8.evt = exit));
TRANS ((a9.evt = enter) <-> (pc9.evt = enter)) & ((a9.evt = exit) <-> (pc9.evt = exit));
TRANS ((a10.evt = enter) <-> (pc10.evt = enter)) & ((a10.evt = exit) <-> (pc10.evt = exit));
TRANS ((a11.evt = enter) <-> (pc11.evt = enter)) & ((a11.evt = exit) <-> (pc11.evt = exit));
TRANS ((a12.evt = enter) <-> (pc12.evt = enter)) & ((a12.evt = exit) <-> (pc12.evt = exit));
TRANS ((a13.evt = enter) <-> (pc13.evt = enter)) & ((a13.evt = exit) <-> (pc13.evt = exit));
TRANS ((a14.evt = enter) <-> (pc14.evt = enter)) & ((a14.evt = exit) <-> (pc14.evt = exit));
TRANS ((a15.evt = enter) <-> (pc15.evt = enter)) & ((a15.evt = exit) <-> (pc15.evt = exit));
TRANS ((a16.evt = enter) <-> (pc16.evt = enter)) & ((a16.evt = exit) <-> (pc16.evt = exit));
TRANS ((a17.evt = enter) <-> (pc17.evt = enter)) & ((a17.evt = exit) <-> (pc17.evt = exit));


MITLSPEC (FALSE SR (pc0.l != error | pc1.l != error)) -> (FALSE SR (TRUE SU (id = 0)));

MODULE Counter(N, id)
VAR
  evt : {stutter, move};
  l : {initial, initCount};

INIT l = initial;

TRANS (evt = stutter) -> next(l) = l;

-- initial -> initCount
TRANS (evt != stutter & l = initial) -> (id = 0 & next(id) = 1 & next(l) = initCount);

-- initCount -> initCount
TRANS (evt != stutter & l = initCount) -> (next(l) = initCount);
TRANS (l = initCount & next(l) = initCount & id >= N) -> (next(id) = 1);
TRANS (l = initCount & next(l) = initCount & id < N) -> (next(id) = id + 1);


MODULE Arbiter(i, id)
VAR
  evt : {stutter, enter, exit};
  l : {s0, s1};

INIT l = s1;

TRANS (evt = stutter) -> next(l) = l;
-- s1 -> s0
TRANS (evt != stutter & l = s1) -> (next(l) = s0 & evt = enter & id = i & next(id) = 0);
-- s0 -> s1
TRANS (evt != stutter & l = s0) -> (next(l) = s1 & evt = exit & next(id) = i);


MODULE ProdCell(A_, Am1, B)
VAR
  evt : {stutter, enter, exit, move};
  l : {not_ready, testing, requesting, critical, testing2, safe, error};
  x : clock((l = not_ready & next(l) = testing) |
            (l = testing & next(l) = not_ready) |
            (l = requesting & next(l) = critical) |
            (l = critical & next(l) = testing2));

INIT l = not_ready;

INVAR (l = testing | l = testing2) -> x <= A_;

TRANS evt = stutter -> (next(l) = l);

-- not_ready -> testing
TRANS (evt != stutter & l = not_ready) -> (evt = move & x <= B & next(l) = testing);

-- testing -> [not_ready | requesting]
TRANS(evt != stutter & l = testing) -> ((next(l) = not_ready | next(l) = requesting) & evt = move);
TRANS (l = testing & next(l) = not_ready) -> (x >= A_);
TRANS (l = testing & next(l) = requesting) -> (x <= Am1);

-- requesting -> critical
TRANS (evt != stutter & l = requesting) -> (next(l) = critical & evt = enter);

-- critical -> [error | testing2]
TRANS (evt != stutter & l = critical) -> (next(l) = error | next(l) = testing2);
TRANS (l = critical & next(l) = error) -> (evt = move & x >= B);
TRANS (l = critical & next(l) = testing2) -> (evt = exit & x <= Am1);

-- testing2 -> [error | safe]
TRANS (evt != stutter & l = testing2) -> ((next(l) = error | next(l) = safe) & evt = move);
TRANS (l = testing2 & next(l) = error) -> (x >= A_);
TRANS (l = testing2 & next(l) = safe) -> (x <= Am1);

-- error -> error
TRANS (evt != stutter & l = error) -> next(l) = error

-- safe -> not_ready
TRANS (evt != stutter & l = safe) -> next(l) = not_ready;
