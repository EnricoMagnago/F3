MODULE main
DEFINE
  SA := 20;
  TD := 0;
  TRTT := 220;

VAR
  r : Ring(TD);
  st0 : ST(0, SA, TRTT);
  st1 : ST(1, SA, TRTT);
  st2 : ST(2, SA, TRTT);
  st3 : ST(3, SA, TRTT);


TRANS r.evt != stutter | (st0.evt != stutter) |(st1.evt != stutter) |(st2.evt != stutter) |(st3.evt != stutter);

TRANS ((r.evt = rt & r.evt_id = 0) <-> st0.evt = rt) & ((r.evt = tt & r.evt_id = 0) <-> st0.evt = tt) & ((r.evt = rt & r.evt_id = 1) <-> st1.evt = rt) & ((r.evt = tt & r.evt_id = 1) <-> st1.evt = tt) & ((r.evt = rt & r.evt_id = 2) <-> st2.evt = rt) & ((r.evt = tt & r.evt_id = 2) <-> st2.evt = tt) & ((r.evt = rt & r.evt_id = 3) <-> st3.evt = rt) & ((r.evt = tt & r.evt_id = 3) <-> st3.evt = tt);

MITLSPEC (FALSE SR (TRUE SU (st0.l = y_async)));

MODULE Ring(TD)
VAR
  evt : {stutter, rt, tt};
  evt_id : 0..3;
  l : {ring_to_counter, ring_counter};
  counter : 0..3;
  x : clock((l = ring_counter & next(l) = ring_to_counter));

INIT l = ring_to_counter & counter = 0;
INVAR l = ring_to_counter -> x <= TD;

TRANS evt = stutter -> (next(l) = l & next(counter) = counter);

-- ring_to_counter -> ring_counter
TRANS (evt != stutter & l = ring_to_counter) -> (x <= TD & evt = tt & evt_id = counter & next(l) = ring_counter & next(counter) = counter);

-- ring_counter -> ring_to_counter (counter < N)
TRANS (evt != stutter & l = ring_counter & counter < 3) -> (evt = rt & evt_id = counter & next(counter) = counter + 1 & next(l) = ring_to_counter);

-- ring_counter -> ring_to_counter (counter = N)
TRANS (evt != stutter & l = ring_counter & counter = 3) -> (evt = rt & evt_id = counter & next(counter) = 0 & next(l) = ring_to_counter);


MODULE ST(id, SA, TRTT)
VAR
  evt : {stutter, move, rt, tt};
  x : clock((l = z_idle & next(l) = z_sync) |
            (l = y_idle & next(l) = y_sync));
  y : clock((l = z_idle & next(l) = z_sync));
  z : clock((l = y_idle & next(l) = y_sync));
  l : {z_idle, z_sync, z_async, y_idle, y_sync, y_async};

INIT l = z_idle;

INVAR l = z_sync -> x <= SA;
INVAR l = z_async -> x <= TRTT;
-- INVAR l = y_sync -> x <= SA;
INVAR l = y_async -> x <= TRTT;

TRANS evt = stutter -> (next(l) = l);

-- z_idle -> z_sync
TRANS (evt != stutter & l = z_idle) -> (evt = tt & next(l) = z_sync);

-- z_sync -> [z_async | y_idle]
TRANS (evt != stutter & l = z_sync) -> (next(l) = z_async | next(l) = y_idle);
TRANS (l = z_sync & next(l) = z_async) -> (x >= SA & z < TRTT & evt = move);
TRANS (l = z_sync & next(l) = y_idle) -> (x >= SA & z >= TRTT & evt = rt);

-- z_async -> y_idle
TRANS (evt != stutter & l = z_async) -> (next(l) = y_idle & evt = rt);

-- y_idle -> y_sync
TRANS (evt != stutter & l = y_idle) -> (next(l) = y_sync & evt = tt);

-- y_sync -> [y_async | z_idle]
TRANS (evt != stutter & l = y_sync) -> (next(l) = y_async | next(l) = z_idle);
TRANS (l = y_sync & next(l) = y_async) -> (x >= SA & y < TRTT & evt = move);
TRANS (l = y_sync & next(l) = z_idle) -> (x >= SA & y >= TRTT & evt = rt);

-- y_async -> z_idle
TRANS (evt != stutter & l = y_async) -> (next(l) = z_idle & evt = rt);
