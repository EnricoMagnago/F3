MODULE main
DEFINE
  SA := 20;
  TD := 0;
  TRTT := 1320;

VAR
  r : Ring(TD);
  st0 : ST(0, SA, TRTT);
  st1 : ST(1, SA, TRTT);
  st2 : ST(2, SA, TRTT);
  st3 : ST(3, SA, TRTT);
  st4 : ST(4, SA, TRTT);
  st5 : ST(5, SA, TRTT);
  st6 : ST(6, SA, TRTT);
  st7 : ST(7, SA, TRTT);
  st8 : ST(8, SA, TRTT);
  st9 : ST(9, SA, TRTT);
  st10 : ST(10, SA, TRTT);
  st11 : ST(11, SA, TRTT);
  st12 : ST(12, SA, TRTT);
  st13 : ST(13, SA, TRTT);
  st14 : ST(14, SA, TRTT);
  st15 : ST(15, SA, TRTT);
  st16 : ST(16, SA, TRTT);
  st17 : ST(17, SA, TRTT);
  st18 : ST(18, SA, TRTT);
  st19 : ST(19, SA, TRTT);
  st20 : ST(20, SA, TRTT);
  st21 : ST(21, SA, TRTT);
  st22 : ST(22, SA, TRTT);
  st23 : ST(23, SA, TRTT);
  st24 : ST(24, SA, TRTT);
  st25 : ST(25, SA, TRTT);


TRANS r.evt != stutter | (st0.evt != stutter) |(st1.evt != stutter) |(st2.evt != stutter) |(st3.evt != stutter) |(st4.evt != stutter) |(st5.evt != stutter) |(st6.evt != stutter) |(st7.evt != stutter) |(st8.evt != stutter) |(st9.evt != stutter) |(st10.evt != stutter) |(st11.evt != stutter) |(st12.evt != stutter) |(st13.evt != stutter) |(st14.evt != stutter) |(st15.evt != stutter) |(st16.evt != stutter) |(st17.evt != stutter) |(st18.evt != stutter) |(st19.evt != stutter) |(st20.evt != stutter) |(st21.evt != stutter) |(st22.evt != stutter) |(st23.evt != stutter) |(st24.evt != stutter) |(st25.evt != stutter);

TRANS ((r.evt = rt & r.evt_id = 0) <-> st0.evt = rt) & ((r.evt = tt & r.evt_id = 0) <-> st0.evt = tt) & ((r.evt = rt & r.evt_id = 1) <-> st1.evt = rt) & ((r.evt = tt & r.evt_id = 1) <-> st1.evt = tt) & ((r.evt = rt & r.evt_id = 2) <-> st2.evt = rt) & ((r.evt = tt & r.evt_id = 2) <-> st2.evt = tt) & ((r.evt = rt & r.evt_id = 3) <-> st3.evt = rt) & ((r.evt = tt & r.evt_id = 3) <-> st3.evt = tt) & ((r.evt = rt & r.evt_id = 4) <-> st4.evt = rt) & ((r.evt = tt & r.evt_id = 4) <-> st4.evt = tt) & ((r.evt = rt & r.evt_id = 5) <-> st5.evt = rt) & ((r.evt = tt & r.evt_id = 5) <-> st5.evt = tt) & ((r.evt = rt & r.evt_id = 6) <-> st6.evt = rt) & ((r.evt = tt & r.evt_id = 6) <-> st6.evt = tt) & ((r.evt = rt & r.evt_id = 7) <-> st7.evt = rt) & ((r.evt = tt & r.evt_id = 7) <-> st7.evt = tt) & ((r.evt = rt & r.evt_id = 8) <-> st8.evt = rt) & ((r.evt = tt & r.evt_id = 8) <-> st8.evt = tt) & ((r.evt = rt & r.evt_id = 9) <-> st9.evt = rt) & ((r.evt = tt & r.evt_id = 9) <-> st9.evt = tt) & ((r.evt = rt & r.evt_id = 10) <-> st10.evt = rt) & ((r.evt = tt & r.evt_id = 10) <-> st10.evt = tt) & ((r.evt = rt & r.evt_id = 11) <-> st11.evt = rt) & ((r.evt = tt & r.evt_id = 11) <-> st11.evt = tt) & ((r.evt = rt & r.evt_id = 12) <-> st12.evt = rt) & ((r.evt = tt & r.evt_id = 12) <-> st12.evt = tt) & ((r.evt = rt & r.evt_id = 13) <-> st13.evt = rt) & ((r.evt = tt & r.evt_id = 13) <-> st13.evt = tt) & ((r.evt = rt & r.evt_id = 14) <-> st14.evt = rt) & ((r.evt = tt & r.evt_id = 14) <-> st14.evt = tt) & ((r.evt = rt & r.evt_id = 15) <-> st15.evt = rt) & ((r.evt = tt & r.evt_id = 15) <-> st15.evt = tt) & ((r.evt = rt & r.evt_id = 16) <-> st16.evt = rt) & ((r.evt = tt & r.evt_id = 16) <-> st16.evt = tt) & ((r.evt = rt & r.evt_id = 17) <-> st17.evt = rt) & ((r.evt = tt & r.evt_id = 17) <-> st17.evt = tt) & ((r.evt = rt & r.evt_id = 18) <-> st18.evt = rt) & ((r.evt = tt & r.evt_id = 18) <-> st18.evt = tt) & ((r.evt = rt & r.evt_id = 19) <-> st19.evt = rt) & ((r.evt = tt & r.evt_id = 19) <-> st19.evt = tt) & ((r.evt = rt & r.evt_id = 20) <-> st20.evt = rt) & ((r.evt = tt & r.evt_id = 20) <-> st20.evt = tt) & ((r.evt = rt & r.evt_id = 21) <-> st21.evt = rt) & ((r.evt = tt & r.evt_id = 21) <-> st21.evt = tt) & ((r.evt = rt & r.evt_id = 22) <-> st22.evt = rt) & ((r.evt = tt & r.evt_id = 22) <-> st22.evt = tt) & ((r.evt = rt & r.evt_id = 23) <-> st23.evt = rt) & ((r.evt = tt & r.evt_id = 23) <-> st23.evt = tt) & ((r.evt = rt & r.evt_id = 24) <-> st24.evt = rt) & ((r.evt = tt & r.evt_id = 24) <-> st24.evt = tt) & ((r.evt = rt & r.evt_id = 25) <-> st25.evt = rt) & ((r.evt = tt & r.evt_id = 25) <-> st25.evt = tt);

MITLSPEC (FALSE SR (TRUE SU (st0.l = y_async)));

MODULE Ring(TD)
VAR
  evt : {stutter, rt, tt};
  evt_id : 0..25;
  l : {ring_to_counter, ring_counter};
  counter : 0..25;
  x : clock((l = ring_counter & next(l) = ring_to_counter));

INIT l = ring_to_counter & counter = 0;
INVAR l = ring_to_counter -> x <= TD;

TRANS evt = stutter -> (next(l) = l & next(counter) = counter);

-- ring_to_counter -> ring_counter
TRANS (evt != stutter & l = ring_to_counter) -> (x <= TD & evt = tt & evt_id = counter & next(l) = ring_counter & next(counter) = counter);

-- ring_counter -> ring_to_counter (counter < N)
TRANS (evt != stutter & l = ring_counter & counter < 25) -> (evt = rt & evt_id = counter & next(counter) = counter + 1 & next(l) = ring_to_counter);

-- ring_counter -> ring_to_counter (counter = N)
TRANS (evt != stutter & l = ring_counter & counter = 25) -> (evt = rt & evt_id = counter & next(counter) = 0 & next(l) = ring_to_counter);


MODULE ST(id, SA, TRTT)
VAR
  evt : {stutter, move, rt, tt};
  x : clock((l = z_idle & next(l) = z_sync) |
            (l = y_idle & next(l) = y_sync));
  y : clock((l = z_idle & next(l) = z_sync));
  z : clock((l = y_idle & next(l) = y_sync));
  l : {z_idle, z_sync, z_async, y_idle, y_sync, y_async};

INIT l = z_idle;

INVAR l = z_sync -> x <= SA;
INVAR l = z_async -> x <= TRTT;
-- INVAR l = y_sync -> x <= SA;
INVAR l = y_async -> x <= TRTT;

TRANS evt = stutter -> (next(l) = l);

-- z_idle -> z_sync
TRANS (evt != stutter & l = z_idle) -> (evt = tt & next(l) = z_sync);

-- z_sync -> [z_async | y_idle]
TRANS (evt != stutter & l = z_sync) -> (next(l) = z_async | next(l) = y_idle);
TRANS (l = z_sync & next(l) = z_async) -> (x >= SA & z < TRTT & evt = move);
TRANS (l = z_sync & next(l) = y_idle) -> (x >= SA & z >= TRTT & evt = rt);

-- z_async -> y_idle
TRANS (evt != stutter & l = z_async) -> (next(l) = y_idle & evt = rt);

-- y_idle -> y_sync
TRANS (evt != stutter & l = y_idle) -> (next(l) = y_sync & evt = tt);

-- y_sync -> [y_async | z_idle]
TRANS (evt != stutter & l = y_sync) -> (next(l) = y_async | next(l) = z_idle);
TRANS (l = y_sync & next(l) = y_async) -> (x >= SA & y < TRTT & evt = move);
TRANS (l = y_sync & next(l) = z_idle) -> (x >= SA & y >= TRTT & evt = rt);

-- y_async -> z_idle
TRANS (evt != stutter & l = y_async) -> (next(l) = z_idle & evt = rt);
