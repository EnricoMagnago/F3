from typing import Tuple, List, Iterator, Iterable, Optional
from itertools import chain

from pysmt.environment import Environment as PysmtEnv
import pysmt.typing as types
from pysmt.fnode import FNode

from ineq import Ineq, Expr
from rewritings import TimesDistributor
from canonize import Canonizer
from utils import log, default_key


_LOG_LVL = 3


def _matrix_product(env: PysmtEnv, keys: List[FNode], coeffs: List[FNode],
                    ineqs: List[Ineq], td: TimesDistributor,
                    expr_type=types.REAL) -> Tuple[List[Expr], Expr]:
    """Return FNodes representing product of coeffs * ineqs

    Ineqs is: Ax < b or Ax <= b, returns coefs * A, coefs * b.
    Missing keys in ineq are implicitly 0, hence does not generate
    the corresponding constraints.
    """
    assert isinstance(env, PysmtEnv)
    assert isinstance(keys, list)
    assert all(isinstance(k, FNode) for k in keys)
    assert all(k in env.formula_manager.formulae.values()
               for k in keys)
    assert isinstance(coeffs, list)
    assert all(isinstance(c, FNode) for c in coeffs)
    assert all(c in env.formula_manager.formulae.values()
               for c in coeffs)
    assert isinstance(ineqs, list)
    assert all(isinstance(ineq, Ineq) for ineq in ineqs)
    assert all(ineq.env == env for ineq in ineqs)
    assert len(coeffs) == len(ineqs)
    assert isinstance(td, TimesDistributor)
    assert expr_type.is_real_type() or expr_type.is_int_type()

    mgr = env.formula_manager

    coeffs_b = Expr(env, expr_type, td)
    coeffs_A = [Expr(env, expr_type, td) for _ in keys]

    if not ineqs:
        return coeffs_A, coeffs_b

    coeffs_b.plus(*[Expr(env, expr_type, td,
                         formula=coeff).times(ineq.rhs)
                    for coeff, ineq in zip(coeffs, ineqs)])

    for coeff_A, _key in zip(coeffs_A, keys):
        _r_key = mgr.ToReal(_key)
        coeff_A.plus(*[Expr(env, expr_type, td,
                            formula=coeff).times(ineq.lhs[_key])
                       for coeff, ineq in zip(coeffs, ineqs)
                       if _key in ineq.lhs],
                     *[Expr(env, expr_type, td,
                            formula=coeff).times(ineq.lhs[_r_key])
                       for coeff, ineq in zip(coeffs, ineqs)
                       if ineq.rhs.expr_type.is_real_type() and
                       _r_key in ineq.lhs])

    return coeffs_A, coeffs_b


def motzkin_transpose(env: PysmtEnv, ineqs: Iterable[FNode],
                      td: TimesDistributor,
                      params: Optional[Iterable[FNode]] = None) -> Iterator[FNode]:
    """Constraint generated by applying Motzkin transposition theorem.

    Returns list of conjuncts whose satisfying assignment identifies
    the coefficients proving the unsatisfiability of ineqs.
    Ineq can contain also equalities.
        forall x : !(Ax <= b & Cx < d)
        iff
        exists l0, l1 :
               l0 A + l1 C = 0 & l0 b + l1 d <= 0 & (l1 != 0 | l0 b < 0)


    If all ineqs are <=: Ax <= b Motzkin simplifies to:
        exists l0: l0 A = 0 & l0 b <= 0

    If all ineqs are <: Cx < d Motzkin simplifies to:
        exists l1: l1 C = 0 & l1 d < 0

    Args:
        env (PysmtEnv) : pysmt environment
        ineqs (FNode list) : system of inequalities
        params (FNode list) : list of symbolic constants

    Returns:
         list : list of FNodes, conjuncts of formula obtained from
                Motzkin transposition theorem.
    """
    assert isinstance(env, PysmtEnv)
    assert isinstance(ineqs, Iterable)
    assert isinstance(td, TimesDistributor)

    params = frozenset(params) if params else frozenset()
    assert all(isinstance(p, FNode) for p in params)
    assert all(p in env.formula_manager.get_all_symbols() for p in params)

    eqs = []  # equalities (=)
    eq_lambdas = []  # Motzkin's constants for eqs
    les = []  # inequalities with <=
    le_lambdas = []  # Motzkin's constants for leqs
    lts = []  # inequalities with <
    lt_lambdas = []  # Motzkin's constants for lts

    mgr = env.formula_manager
    simpl = env.simplifier.simplify
    serialize = env.serializer.serialize

    log("\tMotzkin coefficients <type> ineqs: ", _LOG_LVL)
    for curr in ineqs:
        assert isinstance(curr, FNode)
        assert curr in mgr.formulae.values()
        ineq = Ineq(env, curr, params, td)
        if __debug__:
            from solver import Solver
            # assert curr <-> ineq valid
            with Solver(env=env) as _solver:
                _solver.add_assertion(mgr.Not(mgr.Iff(curr, ineq.pysmt_ineq())))
                assert _solver.solve() is False, (curr, ineq,
                                                  _solver.get_model())
        ineq.to_real()
        ineq_type = ineq.rhs.expr_type
        symb = None
        if ineq.is_lt():
            symb = mgr.new_fresh_symbol(ineq_type, base="_lt%d_")
            lts.append(ineq)
            lt_lambdas.append(symb)
        elif ineq.is_le():
            symb = mgr.new_fresh_symbol(ineq_type, base="_le%d_")
            les.append(ineq)
            le_lambdas.append(symb)
        else:
            assert ineq.is_eq()
            symb = mgr.new_fresh_symbol(ineq_type, base="_eq%d_")
            eqs.append(ineq)
            eq_lambdas.append(symb)
        log(f"\t    {serialize(symb)}  <{ineq_type}>  {ineq}", _LOG_LVL)

    # rewrite ToReal(s) as s.
    keys = frozenset(map(lambda k: k if not k.is_toreal() else k.arg(0),
                         chain(*[ineq.lhs.keys() for ineq in les],
                               *[ineq.lhs.keys() for ineq in lts],
                               *[ineq.lhs.keys() for ineq in eqs])))
    assert all(len(env.fvo.walk(k) & params) == 0 for k in keys)
    keys = list(sorted(keys, key=default_key))
    le_mat, le_const = _matrix_product(env, keys, le_lambdas, les, td)
    lt_mat, lt_const = _matrix_product(env, keys, lt_lambdas, lts, td)
    eq_mat, eq_const = _matrix_product(env, keys, eq_lambdas, eqs, td)

    assert len(keys) == len(lt_mat)
    assert len(lt_mat) == len(le_mat)
    assert len(eq_mat) == len(lt_mat)
    assert len(eq_mat) == len(le_mat)
    assert isinstance(lt_const, Expr)
    assert isinstance(le_const, Expr)
    assert isinstance(eq_const, Expr)

    r_0 = mgr.Real(0)
    i_0 = mgr.Int(0)

    # build constraint
    # coeffs >= 0 only for inequalities.
    yield from map(lambda x: mgr.GE(x, r_0
                                    if x.symbol_type().is_real_type()
                                    else i_0),
                   chain(lt_lambdas, le_lambdas))

    for i in range(len(keys)):
        r_mat_constr = Expr(env, types.REAL, td)
        i_mat_constr = Expr(env, types.INT, td)
        any_r = False
        any_i = False
        for expr in [lt_mat[i], le_mat[i], eq_mat[i]]:
            if expr.expr_type.is_real_type():
                r_mat_constr.plus(expr)
                any_r = True
            else:
                i_mat_constr.plus(expr)
                any_i = True
        assert any_r or any_i
        r_mat_constr = r_mat_constr.pysmt_expr()
        i_mat_constr = i_mat_constr.pysmt_expr()
        # le_mat + lt_mat + eq_mat = 0
        if any_r and any_i:
            mat_constr = mgr.ToReal(i_mat_constr)
            mat_constr = mgr.Plus(r_mat_constr, mat_constr)
            mat_constr = mgr.Equals(mat_constr, r_0)
        elif any_r:
            assert not any_i
            mat_constr = mgr.Equals(r_mat_constr, r_0)
        else:
            assert any_i and not any_r
            mat_constr = mgr.Equals(i_mat_constr, i_0)

        yield simpl(mat_constr)

    r_const_constr = Expr(env, types.REAL, td)
    i_const_constr = Expr(env, types.INT, td)
    any_i = False
    any_r = False
    for const in [lt_const, le_const, eq_const]:
        if const.expr_type.is_real_type():
            r_const_constr.plus(const)
            any_r = True
        else:
            i_const_constr.plus(const)
            any_i = True

    r_const_constr = r_const_constr.pysmt_expr()
    i_const_constr = i_const_constr.pysmt_expr()
    zero = r_0
    if any_r and any_i:
        const_constr = mgr.ToReal(i_const_constr)
        const_constr = mgr.Plus(r_const_constr, const_constr)
    elif any_r:
        assert not any_i
        const_constr = r_const_constr
    else:
        assert any_i and not any_r
        zero = i_0
        const_constr = i_const_constr

    if not lts:
        # le_const + eq_const < 0
        yield simpl(mgr.LT(const_constr, zero))
    else:
        # le_const + eq_const + lt_const <= 0
        yield simpl(mgr.LE(const_constr, zero))
        # le_const + eq_const + lt_const < 0 or lt_lambdas > 0
        disjunction = list(map(lambda x:
                               mgr.GT(x, r_0
                                      if x.symbol_type().is_real_type()
                                      else i_0),
                               lt_lambdas))
        disjunction.append(mgr.LT(const_constr, zero))
        yield simpl(mgr.Or(disjunction))
